from flask import Flask
from flask import render_template
from flask import request
from flask import jsonify # Pour convertir un tableau en JSON
import sqlite3
import os # compatibilité séparateur windows, linux ...

currentDatabase = os.path.dirname(os.path.abspath(__file__)) + os.sep + 'db' + os.sep + 'vulnerabilites.db'
app = Flask(__name__)

# Vue accueil par défaut qui affiche dans un premier temps toutes les vulnérabilités dans la bdd
@app.route('/')
def index():
    con = sqlite3.connect(currentDatabase)
    cursor = con.cursor()
    req = "SELECT * FROM vulnerabilite"
    result = cursor.execute(req)
    result = result.fetchall()
    return render_template('index.html', vulnerabilities = result)


# Vue qui renvoie la liste des vulnérabilités stockées en base au format JSON
@app.route('/api/vulnerabilities', methods=["GET"])
def get_vulnerabilities():
    con = sqlite3.connect(currentDatabase)
    cursor = con.cursor()
    req = "SELECT * FROM vulnerabilite"
    result = cursor.execute(req)
    result = result.fetchall()
    con.close()
    return jsonify(vulnerabilities = result) # Convertit JSON



# Vue abstraite qui sert à postuler le formulaire
@app.route('/api/vulnerabilities', methods=["POST"]) 
def create_vulnerability():
    datas = request.get_json(force=True)
    titre = datas['titre']
    impact = datas['impact']
    exploitation = datas['exploitation']
    risque = datas['risque']


    if titre and impact and exploitation: # On vérifie si tous les champs ne sont pas vides
        con = sqlite3.connect(currentDatabase)
        cursor = con.cursor()
        value = [
            (titre),
            (impact),
            (exploitation),
            (risque)
        ]
        cursor.execute("INSERT INTO vulnerabilite (intitule, impact, exploitation, risque) VALUES (?, ?, ?, ?)", value) # Requête préparée
        con.commit()
        con.close()
        return ('', 204)
    return ('Champ(s) vide(s)', 404)


if __name__ == "__main__":
    app.run(debug=True)